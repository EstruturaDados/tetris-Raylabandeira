#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define TAM_FILA 5
#define TAM_PILHA 3

// Estrutura da pe√ßa
typedef struct {
    int id;
    char nome[2]; // 'I', 'O', 'T', 'L'
} Peca;

// Fila circular
typedef struct {
    Peca pecas[TAM_FILA];
    int frente;
    int tras;
    int quantidade;
} Fila;

// Pilha linear
typedef struct {
    Peca pecas[TAM_PILHA];
    int topo;
} Pilha;

// Hist√≥rico para desfazer
typedef struct {
    Peca ultimaJogada;
    int ativa;
} Historico;

// Gera pe√ßa aleat√≥ria
Peca gerarPeca(int id) {
    Peca nova;
    nova.id = id;
    char tipos[4][2] = {"I", "O", "T", "L"};
    strcpy(nova.nome, tipos[rand() % 4]);
    return nova;
}

// Inicializa fila com 5 pe√ßas
void inicializarFila(Fila *fila, int *idAtual) {
    fila->frente = 0;
    fila->tras = 0;
    fila->quantidade = 0;
    for (int i = 0; i < TAM_FILA; i++) {
        fila->pecas[fila->tras] = gerarPeca(++(*idAtual));
        fila->tras = (fila->tras + 1) % TAM_FILA;
        fila->quantidade++;
    }
}

// Enfileira nova pe√ßa automaticamente
void enfileirar(Fila *fila, int *idAtual) {
    if (fila->quantidade == TAM_FILA) return;
    fila->pecas[fila->tras] = gerarPeca(++(*idAtual));
    fila->tras = (fila->tras + 1) % TAM_FILA;
    fila->quantidade++;
}

// Remove pe√ßa da frente (jogar)
void jogarPeca(Fila *fila, Historico *hist) {
    if (fila->quantidade == 0) {
        printf("‚ö†Ô∏è Fila vazia!\n");
        return;
    }
    hist->ultimaJogada = fila->pecas[fila->frente];
    hist->ativa = 1;
    fila->frente = (fila->frente + 1) % TAM_FILA;
    fila->quantidade--;
    printf("üïπÔ∏è Pe√ßa jogada: ID %d - Tipo %s\n", hist->ultimaJogada.id, hist->ultimaJogada.nome);
}

// Exibe fila
void exibirFila(Fila *fila) {
    printf("\nüéÆ Fila de Pe√ßas Futuras:\n");
    printf("%-5s %-5s\n", "ID", "Tipo");
    int i = fila->frente;
    for (int count = 0; count < fila->quantidade; count++) {
        printf("%-5d %-5s\n", fila->pecas[i].id, fila->pecas[i].nome);
        i = (i + 1) % TAM_FILA;
    }
}

// Exibe pilha
void exibirPilha(Pilha *pilha) {
    printf("\nüì¶ Pilha de Reserva:\n");
    if (pilha->topo == -1) {
        printf("‚ö†Ô∏è Pilha vazia.\n");
        return;
    }
    printf("%-5s %-5s\n", "ID", "Tipo");
    for (int i = pilha->topo; i >= 0; i--) {
        printf("%-5d %-5s\n", pilha->pecas[i].id, pilha->pecas[i].nome);
    }
}

// Push: reserva pe√ßa da frente da fila
void reservarPeca(Fila *fila, Pilha *pilha) {
    if (pilha->topo == TAM_PILHA - 1) {
        printf("‚ö†Ô∏è Pilha cheia!\n");
        return;
    }
    if (fila->quantidade == 0) {
        printf("‚ö†Ô∏è Fila vazia!\n");
        return;
    }
    pilha->pecas[++(pilha->topo)] = fila->pecas[fila->frente];
    fila->frente = (fila->frente + 1) % TAM_FILA;
    fila->quantidade--;
    printf("üì• Pe√ßa reservada!\n");
}

// Pop: usa pe√ßa reservada
void usarReservada(Pilha *pilha) {
    if (pilha->topo == -1) {
        printf("‚ö†Ô∏è Pilha vazia!\n");
        return;
    }
    Peca usada = pilha->pecas[(pilha->topo)--];
    printf("üì§ Pe√ßa usada: ID %d - Tipo %s\n", usada.id, usada.nome);
}

// Troca pe√ßa do topo da pilha com a da frente da fila
void trocarTopoComFrente(Pilha *pilha, Fila *fila) {
    if (pilha->topo == -1 || fila->quantidade == 0) {
        printf("‚ö†Ô∏è Troca indispon√≠vel!\n");
        return;
    }
    Peca temp = pilha->pecas[pilha->topo];
    pilha->pecas[pilha->topo] = fila->pecas[fila->frente];
    fila->pecas[fila->frente] = temp;
    printf("üîÑ Pe√ßas trocadas!\n");
}

// Desfaz √∫ltima jogada
void desfazerJogada(Fila *fila, Historico *hist) {
    if (!hist->ativa || fila->quantidade == TAM_FILA) {
        printf("‚ö†Ô∏è Nada para desfazer!\n");
        return;
    }
    fila->frente = (fila->frente - 1 + TAM_FILA) % TAM_FILA;
    fila->pecas[fila->frente] = hist->ultimaJogada;
    fila->quantidade++;
    hist->ativa = 0;
    printf("‚Ü©Ô∏è Jogada desfeita!\n");
}

// Inverte fila com pilha
void inverterFilaComPilha(Fila *fila, Pilha *pilha) {
    if (fila->quantidade != pilha->topo + 1) {
        printf("‚ö†Ô∏è Quantidades diferentes! N√£o √© poss√≠vel inverter.\n");
        return;
    }
    for (int i = 0; i <= pilha->topo; i++) {
        int posFila = (fila->frente + i) % TAM_FILA;
        Peca temp = fila->pecas[posFila];
        fila->pecas[posFila] = pilha->pecas[i];
        pilha->pecas[i] = temp;
    }
    printf("üîÅ Fila e pilha invertidas!\n");
}

int main() {
    Fila fila;
    Pilha pilha;
    Historico hist;
    int idAtual = 0;
    int opcao;

    srand(time(NULL));
    pilha.topo = -1;
    hist.ativa = 0;
    inicializarFila(&fila, &idAtual);

    do {
        printf("\n=== MENU TETRIS STACK - MESTRE ===\n");
        printf("1. Jogar pe√ßa\n");
        printf("2. Reservar pe√ßa\n");
        printf("3. Usar pe√ßa reservada\n");
        printf("4. Trocar topo da pilha com frente da fila\n");
        printf("5. Desfazer √∫ltima jogada\n");
        printf("6. Inverter fila com pilha\n");
        printf("0. Sair\n");
        printf("Escolha uma opcao: ");
        scanf("%d", &opcao);

        switch (opcao) {
            case 1:
                jogarPeca(&fila, &hist);
                enfileirar(&fila, &idAtual);
                break;
            case 2:
                reservarPeca(&fila, &pilha);
                enfileirar(&fila, &idAtual);
                break;
            case 3:
                usarReservada(&pilha);
                break;
            case 4:
                trocarTopoComFrente(&pilha, &fila);
                break;
            case 5:
                desfazerJogada(&fila, &hist);
                break;
            case 6:
                inverterFilaComPilha(&fila, &pilha);
                break;
            case 0:
                printf("üëã Saindo do jogo...\n");
                break;
            default:
                printf("‚ö†Ô∏è Opcao invalida.\n");
        }

        exibirFila(&fila);
        exibirPilha(&pilha);

    } while (opcao != 0);

    return 0;
}
